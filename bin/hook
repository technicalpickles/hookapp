#!/usr/bin/env ruby
# frozen_string_literal: true

require 'gli'
require 'hook'

# Main class for GLI app
class App
  extend GLI::App

  program_desc 'CLI interface for Hook.app (macOS)'

  version Hook::VERSION

  subcommand_option_handling :normal
  arguments :strict

  hooker = nil

  # desc 'Describe some switch here'
  # switch [:s,:switch]

  # desc 'Describe some flag here'
  # default_value 'the default'
  # arg_name 'The name of the argument'
  # flag [:f,:flagname]

  desc 'List hooks on a file or url'
  arg_name 'FILE_OR_URL [FILE_OR_URL, ...]'
  command %i[list ls] do |c|
    c.desc 'Output only bookmarks with file paths (exclude e.g. emails)'
    c.switch %i[f files_only], { negatable: false, default_value: false }

    c.desc 'Separate results with NULL separator, only applies with "paths" output for single file argument'
    c.switch %i[null], { negatable: false, default_value: false }

    valid_formats = %w[hooks paths markdown verbose]
    fmt_list = valid_formats.map { |fmt| fmt.sub(/^(.)(.*?)$/, '(\1)\2') }.join(', ')
    c.desc "Output format [#{fmt_list}]"
    c.flag %i[o output_format], { arg_name: 'format', default_value: 'paths' }

    c.action do |_global_options, options, args|
      valid_format = hooker.validate_format(options[:o], valid_formats)
      raise 'Invalid output format' unless valid_format

      result = hooker.linked_bookmarks(args, { files_only: options[:f],
                                               format: valid_format,
                                               null_separator: options[:null] })

      puts result
    end
  end

  desc 'Create bidirectional hooks between two or more files/urls'
  arg_name 'SOURCE [SOURCE, ...] TARGET'
  command %i[link ln] do |c|
    c.desc 'Link every listed file or url to every other'
    c.switch %i[a all],  { negatable: false, default_value: false }

    c.desc 'Paste URL from clipboard'
    c.switch %i[p paste], { negatable: false, default_value: false }

    c.action do |_global_options, options, args|
      if options[:p]
        clipboard = `pbpaste`.strip
        clipboard.valid_hook!
        args.push(clipboard) if clipboard
      end
      if args.length < 2
        raise 'At least 2 files must be specified, or one file with --paste'
      end
      if options[:a]
        puts hooker.link_all(args)
      else
        puts hooker.link_files(args)
      end
    end
  end

  desc 'Copy Hook URL for file/url to clipboard'
  arg_name 'FILE_OR_URL'
  command %i[clip] do |c|
    c.desc 'Copy as Markdown'
    c.switch %i[m markdown]

    c.action do |_global_options, options, args|
      result = hooker.copy_bookmark(args[0], { markdown: options[:m] })
      puts result
    end
  end

  desc 'Remove a hook between two files/urls'
  arg_name 'ITEM_1 ITEM_2'
  command %i[remove rm] do |c|
    c.desc 'Remove ALL links on files, requires confirmation'
    c.switch %i[a all]

    c.action do |_global_options, options, args|
      result = hooker.delete_hooks(args, { all: options[:r] })
      puts result
    end
  end

  desc 'Clone all hooks from one file or url onto another'
  arg_name 'SOURCE TARGET'
  command %i[clone cp] do |c|
    c.action do |_global_options, _options, args|
      raise "Wrong number of arguments. Two file paths or urls required (#{args.length} given)" if args.length != 2

      result = hooker.clone_hooks(args)
      puts result
    end
  end

  desc 'Select from hooks on a file/url and open in default application'
  arg_name 'FILE_OR_URL'
  command %i[select] do |c|
    c.action do |_global_options, _options, args|
      raise "Wrong number of arguments. One file path or url required (#{args.length} given)" if args.length != 1

      hooker.open_linked(args[0])
    end
  end

  desc 'Open the specified file or url in Hook GUI'
  arg_name 'FILE_OR_URL'
  command %i[open gui] do |c|
    c.action do |_global_options, _options, args|
      raise "Wrong number of arguments. One file path or url required (#{args.length} given)" if args.length != 1

      hooker.open_gui(args[0])
    end
  end

  pre do |global, _command, _options, _args|
    # Pre logic here
    # Return true to proceed; false to abort and not call the
    # chosen command
    # Use skips_pre before a command to skip this block
    # on that command only
    hooker = Hooker.new(global)
    true
  end

  post do |_global, _command, _options, _args|
    # Post logic here
    # Use skips_post before a command to skip this
    # block on that command only
  end

  on_error do |exception|
    # Error logic here
    # return false to skip default error handling
    true
  end
end

exit App.run(ARGV)
